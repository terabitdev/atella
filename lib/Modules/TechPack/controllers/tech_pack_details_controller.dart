import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../Data/api/openai_service.dart';

class TechPackDetailsController extends GetxController {
  // Materials & Fabrics
  final mainFabricController = TextEditingController();
  final secondaryMaterialsController = TextEditingController();
  final fabricPropertiesController = TextEditingController();

  // Colors
  final primaryColorController = TextEditingController();
  final alternateColorwaysController = TextEditingController();
  final pantoneController = TextEditingController();

  // Sizes & Measurements
  final sizeRangeController = TextEditingController();
  final measurementChartController = TextEditingController();
  final autogeneratedController = TextEditingController();
  final RxString measurementImagePath = ''.obs;

  // Technical Details
  final accessoriesController = TextEditingController();
  final stitchingController = TextEditingController();
  final decorativeStitchingController = TextEditingController();

  // Labeling & Branding
  final logoPlacementController = TextEditingController();
  final labelsNeededController = TextEditingController();
  final qrCodeController = TextEditingController();

  // Packaging & Shipping
  final packagingTypeController = TextEditingController();
  final foldingInstructionsController = TextEditingController();
  final insertsController = TextEditingController();

  // Production Details
  final costPerPieceController = TextEditingController();
  final quantityController = TextEditingController();
  final deliveryDateController = TextEditingController();

  // Block visibility
  final RxBool showColorsBlock = false.obs;
  final RxBool showSizesBlock = false.obs;
  final RxBool showTechnicalBlock = false.obs;
  final RxBool showLabelingBlock = false.obs;
  final RxBool showPackagingBlock = false.obs;
  final RxBool showProductionBlock = false.obs;

  // Image picker instance
  final ImagePicker _picker = ImagePicker();

  // Tech pack generation state
  final RxBool isGeneratingTechPack = false.obs;
  final RxList<String> generatedTechPackImages = <String>[].obs;
  final RxString selectedDesignImagePath = ''.obs;
  final RxString selectedDesignPrompt = ''.obs;
  Map<String, dynamic> designData = {};

  @override
  void onInit() {
    super.onInit();
    _initializeWithArguments();
  }

  void _initializeWithArguments() {
    // Get arguments passed from generate tech pack screen
    final arguments = Get.arguments as Map<String, dynamic>?;
    if (arguments != null) {
      selectedDesignImagePath.value = arguments['selectedDesignUrl'] ?? '';
      selectedDesignPrompt.value = arguments['designPrompt'] ?? '';
      designData = arguments['designData'] ?? {};
      
      print('Tech Pack Details initialized with:');
      print('Design Image: ${selectedDesignImagePath.value.substring(0, 50)}...');
      print('Design Prompt: ${selectedDesignPrompt.value}');
      print('Design Data: $designData');
    }
  }

  String _extractGarmentType() {
    // Extract garment type from the design prompt and data
    String garmentType = 'garment';
    
    if (designData.isNotEmpty) {
      final creativeBrief = designData['creativeBrief'] as Map<String, dynamic>?;
      if (creativeBrief != null && creativeBrief['garmentType'] != null) {
        garmentType = creativeBrief['garmentType'].toString().toLowerCase();
      }
    }
    
    // Fallback to analyzing the prompt
    if (garmentType == 'garment' && selectedDesignPrompt.value.isNotEmpty) {
      final prompt = selectedDesignPrompt.value.toLowerCase();
      if (prompt.contains('jacket') || prompt.contains('coat')) {
        garmentType = 'jacket';
      } else if (prompt.contains('dress')) {
        garmentType = 'dress';
      } else if (prompt.contains('shirt') || prompt.contains('blouse')) {
        garmentType = 'shirt';
      } else if (prompt.contains('pants') || prompt.contains('trousers')) {
        garmentType = 'pants';
      } else if (prompt.contains('skirt')) {
        garmentType = 'skirt';
      } else if (prompt.contains('hoodie') || prompt.contains('sweatshirt')) {
        garmentType = 'hoodie';
      }
    }
    
    return garmentType;
  }

  void checkMaterialsBlockComplete() {
    if (mainFabricController.text.isNotEmpty &&
        secondaryMaterialsController.text.isNotEmpty &&
        fabricPropertiesController.text.isNotEmpty) {
      showColorsBlock.value = true;
    }
  }

  void checkColorsBlockComplete() {
    if (primaryColorController.text.isNotEmpty &&
        alternateColorwaysController.text.isNotEmpty &&
        pantoneController.text.isNotEmpty) {
      showSizesBlock.value = true;
    }
  }

  void checkSizesBlockComplete() {
    if (sizeRangeController.text.isNotEmpty &&
        measurementChartController.text.isNotEmpty) {
      showTechnicalBlock.value = true;
    }
  }

  void checkTechnicalBlockComplete() {
    if (accessoriesController.text.isNotEmpty &&
        stitchingController.text.isNotEmpty &&
        decorativeStitchingController.text.isNotEmpty) {
      showLabelingBlock.value = true;
    }
  }

  void checkLabelingBlockComplete() {
    if (logoPlacementController.text.isNotEmpty &&
        labelsNeededController.text.isNotEmpty &&
        qrCodeController.text.isNotEmpty) {
      showPackagingBlock.value = true;
    }
  }

  void checkPackagingBlockComplete() {
    if (packagingTypeController.text.isNotEmpty &&
        foldingInstructionsController.text.isNotEmpty &&
        insertsController.text.isNotEmpty) {
      showProductionBlock.value = true;
    }
  }

  void checkProductionBlockComplete() {
    // No further block, but could trigger a summary or enable submit
  }

  Future<void> generateTechPackImages() async {
  try {
    print('=== STARTING DETAILED TECH PACK GENERATION ===');
    isGeneratingTechPack.value = true;
    generatedTechPackImages.clear();

    final techPackDetails = _collectTechPackDetails();
    
    print('Tech Pack Details: $techPackDetails');
    print('Design Data: $designData');

    // Try different prompt approaches in order of preference
    Map<String, String> prompts;
    String approach = '';

    try {
      // First attempt: Full detailed prompts with three views
      approach = 'Detailed Three Views';
      prompts = await OpenAIService.generateTechPackPrompts(
        creativeBrief: designData['creativeBrief'] ?? {},
        refinedConcept: designData['refinedConcept'] ?? {},
        finalDetails: designData['finalDetails'] ?? {},
        techPackDetails: techPackDetails,
        selectedDesignPrompt: selectedDesignPrompt.value,
      );
    } catch (e) {
      try {
        // Second attempt: Advanced detailed with explicit positioning
        approach = 'Advanced Detailed Layout';
        print('Trying advanced detailed prompts...');
        prompts = OpenAIService.getAdvancedDetailedPrompts(techPackDetails, designData['creativeBrief'] ?? {});
      } catch (e2) {
        try {
          // Third attempt: Detailed single view
          approach = 'Detailed Single View';
          print('Trying detailed single view prompts...');
          prompts = OpenAIService.getDetailedSingleViewPrompts(techPackDetails, designData['creativeBrief'] ?? {});
        } catch (e3) {
          // Final fallback: Simplified but detailed
          approach = 'Simplified Detailed';
          print('Using simplified detailed prompts...');
          prompts = OpenAIService.getSimplifiedDetailedPrompts(techPackDetails, designData['creativeBrief'] ?? {});
        }
      }
    }
    
    print('Using approach: $approach');
    print('Manufacturing Prompt: ${prompts['manufacturing_prompt']}');
    print('Technical Prompt: ${prompts['technical_flat_prompt']}');

    // Generate manufacturing layout image
    print('Generating manufacturing layout image...');
    List<String> manufacturingImages = [];
    try {
      manufacturingImages = await OpenAIService.generateDesignImages(
        prompt: prompts['manufacturing_prompt'] ?? '',
        numberOfImages: 1,
        size: '1024x1024',
      );
      print('✅ Manufacturing image generated successfully');
    } catch (e) {
      print('❌ Manufacturing image generation failed: $e');
      throw Exception('Failed to generate manufacturing image');
    }

    // Generate technical flat drawing with detailed approach
    print('Generating detailed technical flat drawing...');
    List<String> technicalImages = [];
    try {
      technicalImages = await OpenAIService.generateDesignImages(
        prompt: prompts['technical_flat_prompt'] ?? '',
        numberOfImages: 1,
        size: '1024x1024', // Try 1024x1792 for vertical if 1024x1024 cuts off
      );
      print('✅ Technical flat drawing generated successfully');
    } catch (e) {
      print('❌ Technical image generation failed, trying fallback: $e');
      
      // Fallback with even simpler prompt
      final fallbackPrompt = 'Technical flat drawing of garment, front view, black lines on white background. Include measurement labels A, B, C, D and construction details. Complete drawing centered with margins.';
      technicalImages = await OpenAIService.generateDesignImages(
        prompt: fallbackPrompt,
        numberOfImages: 1,
        size: '1024x1024',
      );
    }

    // Add images to the list
    generatedTechPackImages.addAll(manufacturingImages);
    generatedTechPackImages.addAll(technicalImages);
    
    print('=== DETAILED TECH PACK GENERATION COMPLETED ===');
    print('Generated ${generatedTechPackImages.length} tech pack images using: $approach');

    // Validate and provide feedback
    if (generatedTechPackImages.length >= 2) {
      print('✅ Both manufacturing and detailed technical images generated successfully');
      Get.snackbar(
        'Success',
        'Detailed tech pack images generated with professional labeling!',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } else {
      print('⚠️ Warning: Only ${generatedTechPackImages.length} images generated');
      Get.snackbar(
        'Partial Success',
        'Some tech pack images generated. Check results.',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.orange,
        colorText: Colors.white,
      );
    }
  } catch (e) {
    print('=== TECH PACK GENERATION ERROR ===');
    print('Error: $e');
    
    Get.snackbar(
      'Error',
      'Failed to generate detailed tech pack images: ${e.toString()}',
      snackPosition: SnackPosition.TOP,
      backgroundColor: Colors.red,
      colorText: Colors.white,
    );
  } finally {
    isGeneratingTechPack.value = false;
  }
}

// Add this function to test different technical drawing approaches
void testTechnicalDrawingPrompts() {
  final techPackDetails = _collectTechPackDetails();
  final creativeBrief = designData['creativeBrief'] ?? {};
  
  print('=== TESTING TECHNICAL DRAWING PROMPTS ===');
  
  // Test detailed three views
  final detailed = OpenAIService.getAdvancedDetailedPrompts(techPackDetails, creativeBrief);
  print('Advanced Detailed: ${detailed['technical_flat_prompt']}');
  
  // Test single detailed view
  final singleView = OpenAIService.getDetailedSingleViewPrompts(techPackDetails, creativeBrief);
  print('Single Detailed: ${singleView['technical_flat_prompt']}');
  
  // Test simplified detailed
  final simplified = OpenAIService.getSimplifiedDetailedPrompts(techPackDetails, creativeBrief);
  print('Simplified Detailed: ${simplified['technical_flat_prompt']}');
}

  // Camera functionality
  Future<void> openCameraForMeasurement() async {
    try {
      // Request camera permission
      PermissionStatus cameraStatus = await Permission.camera.request();
      
      if (cameraStatus.isGranted) {
        final XFile? photo = await _picker.pickImage(
          source: ImageSource.camera,
          imageQuality: 80,
          preferredCameraDevice: CameraDevice.rear,
        );
        
        if (photo != null) {
          measurementImagePath.value = photo.path;
          // Check if sizes block should be shown after image capture
          checkSizesBlockComplete();
        }
      } else if (cameraStatus.isDenied) {
        Get.snackbar(
          'Permission Required',
          'Camera permission is required to take photos.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.orange,
          colorText: Colors.white,
        );
      } else if (cameraStatus.isPermanentlyDenied) {
        Get.snackbar(
          'Permission Denied',
          'Camera permission is permanently denied. Please enable it in app settings.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.red,
          colorText: Colors.white,
          mainButton: TextButton(
            onPressed: () => openAppSettings(),
            child: const Text('Settings', style: TextStyle(color: Color.fromARGB(255, 236, 236, 236))),
          ),
        );
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to open camera: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Optional: Method to pick from gallery as alternative
  Future<void> pickImageFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 80,
      );
      
      if (image != null) {
        measurementImagePath.value = image.path;
        checkSizesBlockComplete();
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to pick image: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Collect all current tech pack details from form inputs
  Map<String, dynamic> _collectTechPackDetails() {
    return {
      'materials': {
        'mainFabric': mainFabricController.text,
        'secondaryMaterials': secondaryMaterialsController.text,
        'fabricProperties': fabricPropertiesController.text,
      },
      'colors': {
        'primaryColor': primaryColorController.text,
        'alternateColorways': alternateColorwaysController.text,
        'pantone': pantoneController.text,
      },
      'sizes': {
        'sizeRange': sizeRangeController.text,
        'measurementChart': measurementChartController.text,
        'measurementImage': measurementImagePath.value,
      },
      'technical': {
        'accessories': accessoriesController.text,
        'stitching': stitchingController.text,
        'decorativeStitching': decorativeStitchingController.text,
      },
      'labeling': {
        'logoPlacement': logoPlacementController.text,
        'labelsNeeded': labelsNeededController.text,
        'qrCode': qrCodeController.text,
      },
      'packaging': {
        'packagingType': packagingTypeController.text,
        'foldingInstructions': foldingInstructionsController.text,
        'inserts': insertsController.text,
      },
      'production': {
        'costPerPiece': costPerPieceController.text,
        'quantity': quantityController.text,
        'deliveryDate': deliveryDateController.text,
      },
    };
  }

  @override
  void onClose() {
    mainFabricController.dispose();
    secondaryMaterialsController.dispose();
    fabricPropertiesController.dispose();
    primaryColorController.dispose();
    alternateColorwaysController.dispose();
    pantoneController.dispose();
    sizeRangeController.dispose();
    measurementChartController.dispose();
    accessoriesController.dispose();
    stitchingController.dispose();
    decorativeStitchingController.dispose();
    logoPlacementController.dispose();
    labelsNeededController.dispose();
    qrCodeController.dispose();
    packagingTypeController.dispose();
    foldingInstructionsController.dispose();
    insertsController.dispose();
    costPerPieceController.dispose();
    quantityController.dispose();
    deliveryDateController.dispose();
    super.onClose();
  }
}

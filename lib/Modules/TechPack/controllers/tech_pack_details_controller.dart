import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../Data/api/openai_service.dart';

class TechPackDetailsController extends GetxController {
  // Materials & Fabrics
  final mainFabricController = TextEditingController();
  final secondaryMaterialsController = TextEditingController();
  final fabricPropertiesController = TextEditingController();

  // Colors
  final primaryColorController = TextEditingController();
  final alternateColorwaysController = TextEditingController();
  final pantoneController = TextEditingController();

  // Sizes & Measurements
  final sizeRangeController = TextEditingController();
  final measurementChartController = TextEditingController();
  final autogeneratedController = TextEditingController();
  final RxString measurementImagePath = ''.obs;

  // Technical Details
  final accessoriesController = TextEditingController();
  final stitchingController = TextEditingController();
  final decorativeStitchingController = TextEditingController();

  // Labeling & Branding
  final logoPlacementController = TextEditingController();
  final labelsNeededController = TextEditingController();
  final qrCodeController = TextEditingController();

  // Packaging & Shipping
  final packagingTypeController = TextEditingController();
  final foldingInstructionsController = TextEditingController();
  final insertsController = TextEditingController();

  // Production Details
  final costPerPieceController = TextEditingController();
  final quantityController = TextEditingController();
  final deliveryDateController = TextEditingController();

  // Block visibility
  final RxBool showColorsBlock = false.obs;
  final RxBool showSizesBlock = false.obs;
  final RxBool showTechnicalBlock = false.obs;
  final RxBool showLabelingBlock = false.obs;
  final RxBool showPackagingBlock = false.obs;
  final RxBool showProductionBlock = false.obs;

  // Image picker instance
  final ImagePicker _picker = ImagePicker();

  // Tech pack generation state
  final RxBool isGeneratingTechPack = false.obs;
  final RxList<String> generatedTechPackImages = <String>[].obs;
  final RxString selectedDesignImagePath = ''.obs;
  final RxString selectedDesignPrompt = ''.obs;
  Map<String, dynamic> designData = {};

  @override
  void onInit() {
    super.onInit();
    _initializeWithArguments();
  }

  void _initializeWithArguments() {
    // Get arguments passed from generate tech pack screen
    final arguments = Get.arguments as Map<String, dynamic>?;
    if (arguments != null) {
      selectedDesignImagePath.value = arguments['selectedDesignUrl'] ?? '';
      selectedDesignPrompt.value = arguments['designPrompt'] ?? '';
      designData = arguments['designData'] ?? {};
      
      print('Tech Pack Details initialized with:');
      print('Design Image: ${selectedDesignImagePath.value.substring(0, 50)}...');
      print('Design Prompt: ${selectedDesignPrompt.value}');
      print('Design Data: $designData');
    }
  }

  String _extractGarmentType() {
    // Extract garment type from the design prompt and data
    String garmentType = 'garment';
    
    if (designData.isNotEmpty) {
      final creativeBrief = designData['creativeBrief'] as Map<String, dynamic>?;
      if (creativeBrief != null && creativeBrief['garmentType'] != null) {
        garmentType = creativeBrief['garmentType'].toString().toLowerCase();
      }
    }
    
    // Fallback to analyzing the prompt
    if (garmentType == 'garment' && selectedDesignPrompt.value.isNotEmpty) {
      final prompt = selectedDesignPrompt.value.toLowerCase();
      if (prompt.contains('jacket') || prompt.contains('coat')) {
        garmentType = 'jacket';
      } else if (prompt.contains('dress')) {
        garmentType = 'dress';
      } else if (prompt.contains('shirt') || prompt.contains('blouse')) {
        garmentType = 'shirt';
      } else if (prompt.contains('pants') || prompt.contains('trousers')) {
        garmentType = 'pants';
      } else if (prompt.contains('skirt')) {
        garmentType = 'skirt';
      } else if (prompt.contains('hoodie') || prompt.contains('sweatshirt')) {
        garmentType = 'hoodie';
      }
    }
    
    return garmentType;
  }

  void checkMaterialsBlockComplete() {
    if (mainFabricController.text.isNotEmpty &&
        secondaryMaterialsController.text.isNotEmpty &&
        fabricPropertiesController.text.isNotEmpty) {
      showColorsBlock.value = true;
    }
  }

  void checkColorsBlockComplete() {
    if (primaryColorController.text.isNotEmpty &&
        alternateColorwaysController.text.isNotEmpty &&
        pantoneController.text.isNotEmpty) {
      showSizesBlock.value = true;
    }
  }

  void checkSizesBlockComplete() {
    if (sizeRangeController.text.isNotEmpty &&
        measurementChartController.text.isNotEmpty) {
      showTechnicalBlock.value = true;
    }
  }

  void checkTechnicalBlockComplete() {
    if (accessoriesController.text.isNotEmpty &&
        stitchingController.text.isNotEmpty &&
        decorativeStitchingController.text.isNotEmpty) {
      showLabelingBlock.value = true;
    }
  }

  void checkLabelingBlockComplete() {
    if (logoPlacementController.text.isNotEmpty &&
        labelsNeededController.text.isNotEmpty &&
        qrCodeController.text.isNotEmpty) {
      showPackagingBlock.value = true;
    }
  }

  void checkPackagingBlockComplete() {
    if (packagingTypeController.text.isNotEmpty &&
        foldingInstructionsController.text.isNotEmpty &&
        insertsController.text.isNotEmpty) {
      showProductionBlock.value = true;
    }
  }

  void checkProductionBlockComplete() {
    // No further block, but could trigger a summary or enable submit
  }

String _generateTechPackPrompt() {
  final garmentType = _extractGarmentType();

  return '''
Create a clean, professional manufacturing tech pack layout image for a ${garmentType}, 
styled exactly like the attached example. 
The tech pack should visually include all sections with icons, Pantone color swatches, 
line art drawing of the garment, and organized information blocks.  

Sections and details to include (use data provided below, or defaults if not given):  

üß∂ **MATERIALS**  
${mainFabricController.text.isNotEmpty ? mainFabricController.text : 'Main fabric composition and weight'};  
${secondaryMaterialsController.text.isNotEmpty ? secondaryMaterialsController.text : 'Secondary fabric composition (rib, trims)'};  
${fabricPropertiesController.text.isNotEmpty ? fabricPropertiesController.text : 'Special treatments or certifications (e.g., OEKO-TEX, pre-shrunk, brushed interior)'}.

üé® **COLORS**  
Primary: ${primaryColorController.text.isNotEmpty ? primaryColorController.text : 'Main color name'} (Pantone ${pantoneController.text.isNotEmpty ? pantoneController.text : 'TBD'}, HEX code if available).  
Alternates: ${alternateColorwaysController.text.isNotEmpty ? alternateColorwaysController.text : 'List alternate colors with Pantone refs'}.  
Include white or other drawcord color if applicable.

üìè **SIZES**  
Size range: ${sizeRangeController.text.isNotEmpty ? sizeRangeController.text : 'XS‚ÄìXXL'}  
Measurements chart: ${measurementChartController.text.isNotEmpty ? measurementChartController.text : 'Include chest & length for each size'}.

ü™° **CONSTRUCTION & HARDWARE**  
${accessoriesController.text.isNotEmpty ? accessoriesController.text : 'List key features such as pockets, eyelets, zippers, buttons'};  
${stitchingController.text.isNotEmpty ? stitchingController.text : 'Main stitching type (double-needle, flatlock, cover-stitch)'};  
${decorativeStitchingController.text.isNotEmpty ? decorativeStitchingController.text : 'Any decorative stitching details'}.

üè∑ **LABELING**  
${logoPlacementController.text.isNotEmpty ? logoPlacementController.text : 'Logo placement (e.g., embroidered chest logo)'};  
${labelsNeededController.text.isNotEmpty ? labelsNeededController.text : 'Type of labels (woven, care, size)'};  
${qrCodeController.text.isNotEmpty ? qrCodeController.text : 'QR code or authenticity tag'}.

üì¶ **PACKAGING**  
${packagingTypeController.text.isNotEmpty ? packagingTypeController.text : 'Packaging material (e.g., compostable mailer, polybag)'};  
${foldingInstructionsController.text.isNotEmpty ? foldingInstructionsController.text : 'Folding and presentation instructions'};  
${insertsController.text.isNotEmpty ? insertsController.text : 'Insert card, tissue, brand booklet'}.

üí∏ **PRODUCTION COSTS & LEAD TIMES**  
${costPerPieceController.text.isNotEmpty ? costPerPieceController.text : 'FOB cost range'};  
${quantityController.text.isNotEmpty ? quantityController.text : 'Production quantity & MOQ'};  
${deliveryDateController.text.isNotEmpty ? deliveryDateController.text : 'Lead time in weeks'}.

Make sure the output is **visually structured** exactly like the example, with:  

- Color swatches with Pantone refs and HEX codes  
- Organized sections with headings and icons  
- Table for sizes  
- Clean typography  
- Minimal modern aesthetic.
''';
}



String _generateTechnicalFlatPrompt() {
  final garmentType = _extractGarmentType();

  return '''
DESIGN REFERENCE: ${selectedDesignPrompt.value.isNotEmpty ? selectedDesignPrompt.value.substring(0, 150) : 'Fashion design'} ‚Äî Create technical flats that match this ${garmentType} design exactly.

Create a technical fashion flat drawing tech pack for the ${garmentType}. Generate professional black and white line drawings showing:

VIEWS: Front and back technical flats of ${garmentType} with construction callouts and features.

ANNOTATIONS with leader lines:
- Construction Details: ${stitchingController.text.isNotEmpty ? stitchingController.text : 'Professional seam construction'}
- Hardware: ${accessoriesController.text.isNotEmpty ? accessoriesController.text : 'Quality hardware placement'}
- Decorative Elements: ${decorativeStitchingController.text.isNotEmpty ? decorativeStitchingController.text : 'Aesthetic finishing details'}

SPECIFICATIONS:
- All measurements in cm of the ${garmentType}.
- Seam types and finishing details of ${garmentType}.
- Stitch types (single/double needle) and specifications of ${garmentType}.
- Pocket/button construction specifications if available of ${garmentType}.

TEXT REQUIREMENTS:
- Large, bold, clear sans-serif font
- High contrast black text on white background
- No text cut off or truncated
- Minimum 1cm spacing between labels and drawing edges

STYLE:
- Professional apparel manufacturing tech pack aesthetic
- Clean technical line work with annotation callouts and leader lines
- Avoid photorealistic rendering; focus on technical sketch style

LAYOUT:
- Prominent front/back views with detailed callouts
- All annotations fit completely within image boundaries
''';
}

/*
Create a technical fashion flat drawing tech pack for the sage green jacket. Generate professional black and white line drawings showing:

VIEWS: Front/back technical flats with construction callouts, side view showing pockets
ANNOTATIONS with leader lines: Cuban collar measurements, button spacing, chest pocket placement, patch pocket dimensions, sleeve/cuff details, seam construction, hem details, topstitching specs, stitch types
SPECIFICATIONS: All measurements in cm, stitch types (single/double needle), seam details, button specifications, pocket construction methods

TEXT REQUIREMENTS: Use large, bold, clear sans-serif font. High contrast black text on white background. Ensure ALL text labels are complete words, fully visible, and positioned with adequate spacing from image edges. No text should be cut off or truncated. Maintain minimum 1cm spacing between labels.

STYLE: Professional apparel manufacturing tech pack aesthetic - clean technical line work with annotation callouts and leader lines. Avoid photorealistic rendering, focus on technical sketch style used in garment production.

LAYOUT: Prominent front/back views with detailed technical callouts surrounding flats, similar to professional manufacturing tech pack layouts. Ensure all annotations fit completely within image¬†boundaries.*/



  Future<void> generateTechPackImages() async {
    try {
      print('=== STARTING TECH PACK GENERATION ===');
      isGeneratingTechPack.value = true;
      generatedTechPackImages.clear();

      // Collect all tech pack details from form inputs
      final techPackDetails = _collectTechPackDetails();
      
      print('Tech Pack Details: $techPackDetails');
      print('Design Data: $designData');
      print('Selected Design Prompt: ${selectedDesignPrompt.value}');

      // Generate dynamic prompts using GPT based on all questionnaire data + tech pack details
      print('Generating dynamic prompts with GPT-4...');
      final dynamicPrompts = await OpenAIService.generateTechPackPrompts(
        creativeBrief: designData['creativeBrief'] ?? {},
        refinedConcept: designData['refinedConcept'] ?? {},
        finalDetails: designData['finalDetails'] ?? {},
        techPackDetails: techPackDetails,
        selectedDesignPrompt: selectedDesignPrompt.value,
      );
      
      print('Generated Manufacturing Prompt: ${dynamicPrompts['manufacturing_prompt']?.substring(0, 150)}...');
      print('Generated Technical Flat Prompt: ${dynamicPrompts['technical_flat_prompt']?.substring(0, 150)}...');

      // Generate images using the dynamic prompts
      print('Generating manufacturing layout image...');
      final techPackImages = await OpenAIService.generateDesignImages(
        prompt: dynamicPrompts['manufacturing_prompt'] ?? _generateTechPackPrompt(),
        numberOfImages: 1,
        size: '1024x1024',
      );

      print('Generating technical flat drawing image...');
      final technicalImages = await OpenAIService.generateDesignImages(
        prompt: dynamicPrompts['technical_flat_prompt'] ?? _generateTechnicalFlatPrompt(),
        numberOfImages: 1,
        size: '1024x1024',
      );

      generatedTechPackImages.addAll(techPackImages);
      generatedTechPackImages.addAll(technicalImages);
      
      print('=== TECH PACK GENERATION COMPLETED ===');
      print('Generated ${generatedTechPackImages.length} tech pack images');

      Get.snackbar(
        'Success',
        'Tech pack images generated successfully with your specifications!',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } catch (e) {
      print('=== TECH PACK GENERATION ERROR ===');
      print('Error: $e');
      
      Get.snackbar(
        'Error',
        'Failed to generate tech pack images: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    } finally {
      isGeneratingTechPack.value = false;
    }
  }

  // Camera functionality
  Future<void> openCameraForMeasurement() async {
    try {
      // Request camera permission
      PermissionStatus cameraStatus = await Permission.camera.request();
      
      if (cameraStatus.isGranted) {
        final XFile? photo = await _picker.pickImage(
          source: ImageSource.camera,
          imageQuality: 80,
          preferredCameraDevice: CameraDevice.rear,
        );
        
        if (photo != null) {
          measurementImagePath.value = photo.path;
          // Check if sizes block should be shown after image capture
          checkSizesBlockComplete();
        }
      } else if (cameraStatus.isDenied) {
        Get.snackbar(
          'Permission Required',
          'Camera permission is required to take photos.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.orange,
          colorText: Colors.white,
        );
      } else if (cameraStatus.isPermanentlyDenied) {
        Get.snackbar(
          'Permission Denied',
          'Camera permission is permanently denied. Please enable it in app settings.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.red,
          colorText: Colors.white,
          mainButton: TextButton(
            onPressed: () => openAppSettings(),
            child: const Text('Settings', style: TextStyle(color: Color.fromARGB(255, 236, 236, 236))),
          ),
        );
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to open camera: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Optional: Method to pick from gallery as alternative
  Future<void> pickImageFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 80,
      );
      
      if (image != null) {
        measurementImagePath.value = image.path;
        checkSizesBlockComplete();
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to pick image: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Collect all current tech pack details from form inputs
  Map<String, dynamic> _collectTechPackDetails() {
    return {
      'materials': {
        'mainFabric': mainFabricController.text,
        'secondaryMaterials': secondaryMaterialsController.text,
        'fabricProperties': fabricPropertiesController.text,
      },
      'colors': {
        'primaryColor': primaryColorController.text,
        'alternateColorways': alternateColorwaysController.text,
        'pantone': pantoneController.text,
      },
      'sizes': {
        'sizeRange': sizeRangeController.text,
        'measurementChart': measurementChartController.text,
        'measurementImage': measurementImagePath.value,
      },
      'technical': {
        'accessories': accessoriesController.text,
        'stitching': stitchingController.text,
        'decorativeStitching': decorativeStitchingController.text,
      },
      'labeling': {
        'logoPlacement': logoPlacementController.text,
        'labelsNeeded': labelsNeededController.text,
        'qrCode': qrCodeController.text,
      },
      'packaging': {
        'packagingType': packagingTypeController.text,
        'foldingInstructions': foldingInstructionsController.text,
        'inserts': insertsController.text,
      },
      'production': {
        'costPerPiece': costPerPieceController.text,
        'quantity': quantityController.text,
        'deliveryDate': deliveryDateController.text,
      },
    };
  }

  @override
  void onClose() {
    mainFabricController.dispose();
    secondaryMaterialsController.dispose();
    fabricPropertiesController.dispose();
    primaryColorController.dispose();
    alternateColorwaysController.dispose();
    pantoneController.dispose();
    sizeRangeController.dispose();
    measurementChartController.dispose();
    accessoriesController.dispose();
    stitchingController.dispose();
    decorativeStitchingController.dispose();
    logoPlacementController.dispose();
    labelsNeededController.dispose();
    qrCodeController.dispose();
    packagingTypeController.dispose();
    foldingInstructionsController.dispose();
    insertsController.dispose();
    costPerPieceController.dispose();
    quantityController.dispose();
    deliveryDateController.dispose();
    super.onClose();
  }
}

import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../Data/api/openai_service.dart';

class TechPackDetailsController extends GetxController {
  // Materials & Fabrics
  final mainFabricController = TextEditingController();
  final secondaryMaterialsController = TextEditingController();
  final fabricPropertiesController = TextEditingController();

  // Colors
  final primaryColorController = TextEditingController();
  final alternateColorwaysController = TextEditingController();
  final pantoneController = TextEditingController();

  // Sizes & Measurements
  final sizeRangeController = TextEditingController();
  final measurementChartController = TextEditingController();
  final autogeneratedController = TextEditingController();
  final RxString measurementImagePath = ''.obs;

  // Technical Details
  final accessoriesController = TextEditingController();
  final stitchingController = TextEditingController();
  final decorativeStitchingController = TextEditingController();

  // Labeling & Branding
  final logoPlacementController = TextEditingController();
  final labelsNeededController = TextEditingController();
  final qrCodeController = TextEditingController();

  // Packaging & Shipping
  final packagingTypeController = TextEditingController();
  final foldingInstructionsController = TextEditingController();
  final insertsController = TextEditingController();

  // Production Details
  final costPerPieceController = TextEditingController();
  final quantityController = TextEditingController();
  final deliveryDateController = TextEditingController();

  // Block visibility
  final RxBool showColorsBlock = false.obs;
  final RxBool showSizesBlock = false.obs;
  final RxBool showTechnicalBlock = false.obs;
  final RxBool showLabelingBlock = false.obs;
  final RxBool showPackagingBlock = false.obs;
  final RxBool showProductionBlock = false.obs;

  // Image picker instance
  final ImagePicker _picker = ImagePicker();

  // Tech pack generation state
  final RxBool isGeneratingTechPack = false.obs;
  final RxList<String> generatedTechPackImages = <String>[].obs;
  final RxString selectedDesignImagePath = ''.obs;
  final RxString selectedDesignPrompt = ''.obs;
  Map<String, dynamic> designData = {};

  @override
  void onInit() {
    super.onInit();
    _initializeWithArguments();
  }

  void _initializeWithArguments() {
    // Get arguments passed from generate tech pack screen
    final arguments = Get.arguments as Map<String, dynamic>?;
    if (arguments != null) {
      selectedDesignImagePath.value = arguments['selectedDesignUrl'] ?? '';
      selectedDesignPrompt.value = arguments['designPrompt'] ?? '';
      designData = arguments['designData'] ?? {};
      
      print('Tech Pack Details initialized with:');
      print('Design Image: ${selectedDesignImagePath.value.substring(0, 50)}...');
      print('Design Prompt: ${selectedDesignPrompt.value}');
      print('Design Data: $designData');
    }
  }

  String _extractGarmentType() {
    // Extract garment type from the design prompt and data
    String garmentType = 'garment';
    
    if (designData.isNotEmpty) {
      final creativeBrief = designData['creativeBrief'] as Map<String, dynamic>?;
      if (creativeBrief != null && creativeBrief['garmentType'] != null) {
        garmentType = creativeBrief['garmentType'].toString().toLowerCase();
      }
    }
    
    // Fallback to analyzing the prompt
    if (garmentType == 'garment' && selectedDesignPrompt.value.isNotEmpty) {
      final prompt = selectedDesignPrompt.value.toLowerCase();
      if (prompt.contains('jacket') || prompt.contains('coat')) {
        garmentType = 'jacket';
      } else if (prompt.contains('dress')) {
        garmentType = 'dress';
      } else if (prompt.contains('shirt') || prompt.contains('blouse')) {
        garmentType = 'shirt';
      } else if (prompt.contains('pants') || prompt.contains('trousers')) {
        garmentType = 'pants';
      } else if (prompt.contains('skirt')) {
        garmentType = 'skirt';
      } else if (prompt.contains('hoodie') || prompt.contains('sweatshirt')) {
        garmentType = 'hoodie';
      }
    }
    
    return garmentType;
  }

  void checkMaterialsBlockComplete() {
    if (mainFabricController.text.isNotEmpty &&
        secondaryMaterialsController.text.isNotEmpty &&
        fabricPropertiesController.text.isNotEmpty) {
      showColorsBlock.value = true;
    }
  }

  void checkColorsBlockComplete() {
    if (primaryColorController.text.isNotEmpty &&
        alternateColorwaysController.text.isNotEmpty &&
        pantoneController.text.isNotEmpty) {
      showSizesBlock.value = true;
    }
  }

  void checkSizesBlockComplete() {
    if (sizeRangeController.text.isNotEmpty &&
        measurementChartController.text.isNotEmpty) {
      showTechnicalBlock.value = true;
    }
  }

  void checkTechnicalBlockComplete() {
    if (accessoriesController.text.isNotEmpty &&
        stitchingController.text.isNotEmpty &&
        decorativeStitchingController.text.isNotEmpty) {
      showLabelingBlock.value = true;
    }
  }

  void checkLabelingBlockComplete() {
    if (logoPlacementController.text.isNotEmpty &&
        labelsNeededController.text.isNotEmpty &&
        qrCodeController.text.isNotEmpty) {
      showPackagingBlock.value = true;
    }
  }

  void checkPackagingBlockComplete() {
    if (packagingTypeController.text.isNotEmpty &&
        foldingInstructionsController.text.isNotEmpty &&
        insertsController.text.isNotEmpty) {
      showProductionBlock.value = true;
    }
  }

  void checkProductionBlockComplete() {
    // No further block, but could trigger a summary or enable submit
  }

String _generateTechPackPrompt() {
  final garmentType = _extractGarmentType();

  return '''
Create a clean, professional manufacturing tech pack layout image for a ${garmentType}, 
styled exactly like the attached example. 
The tech pack should visually include all sections with icons, Pantone color swatches, 
line art drawing of the garment, and organized information blocks.  

Sections and details to include (use data provided below, or defaults if not given):  

üß∂ **MATERIALS**  
${mainFabricController.text.isNotEmpty ? mainFabricController.text : 'Main fabric composition and weight'};  
${secondaryMaterialsController.text.isNotEmpty ? secondaryMaterialsController.text : 'Secondary fabric composition (rib, trims)'};  
${fabricPropertiesController.text.isNotEmpty ? fabricPropertiesController.text : 'Special treatments or certifications (e.g., OEKO-TEX, pre-shrunk, brushed interior)'}.

üé® **COLORS**  
Primary: ${primaryColorController.text.isNotEmpty ? primaryColorController.text : 'Main color name'} (Pantone ${pantoneController.text.isNotEmpty ? pantoneController.text : 'TBD'}, HEX code if available).  
Alternates: ${alternateColorwaysController.text.isNotEmpty ? alternateColorwaysController.text : 'List alternate colors with Pantone refs'}.  
Include white or other drawcord color if applicable.

üìè **SIZES**  
Size range: ${sizeRangeController.text.isNotEmpty ? sizeRangeController.text : 'XS‚ÄìXXL'}  
Measurements chart: ${measurementChartController.text.isNotEmpty ? measurementChartController.text : 'Include chest & length for each size'}.

ü™° **CONSTRUCTION & HARDWARE**  
${accessoriesController.text.isNotEmpty ? accessoriesController.text : 'List key features such as pockets, eyelets, zippers, buttons'};  
${stitchingController.text.isNotEmpty ? stitchingController.text : 'Main stitching type (double-needle, flatlock, cover-stitch)'};  
${decorativeStitchingController.text.isNotEmpty ? decorativeStitchingController.text : 'Any decorative stitching details'}.

üè∑ **LABELING**  
${logoPlacementController.text.isNotEmpty ? logoPlacementController.text : 'Logo placement (e.g., embroidered chest logo)'};  
${labelsNeededController.text.isNotEmpty ? labelsNeededController.text : 'Type of labels (woven, care, size)'};  
${qrCodeController.text.isNotEmpty ? qrCodeController.text : 'QR code or authenticity tag'}.

üì¶ **PACKAGING**  
${packagingTypeController.text.isNotEmpty ? packagingTypeController.text : 'Packaging material (e.g., compostable mailer, polybag)'};  
${foldingInstructionsController.text.isNotEmpty ? foldingInstructionsController.text : 'Folding and presentation instructions'};  
${insertsController.text.isNotEmpty ? insertsController.text : 'Insert card, tissue, brand booklet'}.

üí∏ **PRODUCTION COSTS & LEAD TIMES**  
${costPerPieceController.text.isNotEmpty ? costPerPieceController.text : 'FOB cost range'};  
${quantityController.text.isNotEmpty ? quantityController.text : 'Production quantity & MOQ'};  
${deliveryDateController.text.isNotEmpty ? deliveryDateController.text : 'Lead time in weeks'}.

Make sure the output is **visually structured** exactly like the example, with:  

- Color swatches with Pantone refs and HEX codes  
- Organized sections with headings and icons  
- Table for sizes  
- Clean typography  
- Minimal modern aesthetic.
''';
}



String _generateTechnicalFlatPrompt() {
  final garmentType = _extractGarmentType();

  return '''
DESIGN REFERENCE: ${selectedDesignPrompt.value.isNotEmpty ? selectedDesignPrompt.value.substring(0, 150) : 'Fashion design'} ‚Äî Create technical flats that match this ${garmentType} design exactly.

Create a technical fashion flat drawing tech pack for the ${garmentType}. Generate professional black and white line drawings showing:

VIEWS: Front and back technical flats of ${garmentType} with construction callouts and features.

ANNOTATIONS with leader lines:
- Construction Details: ${stitchingController.text.isNotEmpty ? stitchingController.text : 'Professional seam construction'}
- Hardware: ${accessoriesController.text.isNotEmpty ? accessoriesController.text : 'Quality hardware placement'}
- Decorative Elements: ${decorativeStitchingController.text.isNotEmpty ? decorativeStitchingController.text : 'Aesthetic finishing details'}

SPECIFICATIONS:
- All measurements in cm of the ${garmentType}.
- Seam types and finishing details of ${garmentType}.
- Stitch types (single/double needle) and specifications of ${garmentType}.
- Pocket/button construction specifications if available of ${garmentType}.

TEXT REQUIREMENTS:
- Large, bold, clear sans-serif font
- High contrast black text on white background
- No text cut off or truncated
- Minimum 1cm spacing between labels and drawing edges

STYLE:
- Professional apparel manufacturing tech pack aesthetic
- Clean technical line work with annotation callouts and leader lines
- Avoid photorealistic rendering; focus on technical sketch style

LAYOUT:
- Prominent front/back views with detailed callouts
- All annotations fit completely within image boundaries
''';
}

/*
Create a technical fashion flat drawing tech pack for the sage green jacket. Generate professional black and white line drawings showing:

VIEWS: Front/back technical flats with construction callouts, side view showing pockets
ANNOTATIONS with leader lines: Cuban collar measurements, button spacing, chest pocket placement, patch pocket dimensions, sleeve/cuff details, seam construction, hem details, topstitching specs, stitch types
SPECIFICATIONS: All measurements in cm, stitch types (single/double needle), seam details, button specifications, pocket construction methods

TEXT REQUIREMENTS: Use large, bold, clear sans-serif font. High contrast black text on white background. Ensure ALL text labels are complete words, fully visible, and positioned with adequate spacing from image edges. No text should be cut off or truncated. Maintain minimum 1cm spacing between labels.

STYLE: Professional apparel manufacturing tech pack aesthetic - clean technical line work with annotation callouts and leader lines. Avoid photorealistic rendering, focus on technical sketch style used in garment production.

LAYOUT: Prominent front/back views with detailed technical callouts surrounding flats, similar to professional manufacturing tech pack layouts. Ensure all annotations fit completely within image¬†boundaries.*/



  // Future<void> generateTechPackImages() async {
  //   try {
  //     print('=== STARTING TECH PACK GENERATION ===');
  //     isGeneratingTechPack.value = true;
  //     generatedTechPackImages.clear();

  //     // Collect all tech pack details from form inputs
  //     final techPackDetails = _collectTechPackDetails();
      
  //     print('Tech Pack Details: $techPackDetails');
  //     print('Design Data: $designData');
  //     print('Selected Design Prompt: ${selectedDesignPrompt.value}');

  //     // Generate dynamic prompts using GPT based on all questionnaire data + tech pack details
  //     print('Generating dynamic prompts with GPT-4...');
  //     final dynamicPrompts = await OpenAIService.generateTechPackPrompts(
  //       creativeBrief: designData['creativeBrief'] ?? {},
  //       refinedConcept: designData['refinedConcept'] ?? {},
  //       finalDetails: designData['finalDetails'] ?? {},
  //       techPackDetails: techPackDetails,
  //       selectedDesignPrompt: selectedDesignPrompt.value,
  //     );
      
  //     print('Generated Manufacturing Prompt: ${dynamicPrompts['manufacturing_prompt']?.substring(0, 150)}...');
  //     print('Generated Technical Flat Prompt: ${dynamicPrompts['technical_flat_prompt']?.substring(0, 150)}...');

  //     // Generate images using the dynamic prompts
  //     print('Generating manufacturing layout image...');
  //     final techPackImages = await OpenAIService.generateDesignImages(
  //       prompt: dynamicPrompts['manufacturing_prompt'] ?? _generateTechPackPrompt(),
  //       numberOfImages: 1,
  //       size: '1024x1024',
  //     );

  //     print('Generating technical flat drawing image...');
  //     final technicalImages = await OpenAIService.generateDesignImages(
  //       prompt: dynamicPrompts['technical_flat_prompt'] ?? _generateTechnicalFlatPrompt(),
  //       numberOfImages: 1,
  //       size: '1024x1024',
  //     );

  //     generatedTechPackImages.addAll(techPackImages);
  //     generatedTechPackImages.addAll(technicalImages);
      
  //     print('=== TECH PACK GENERATION COMPLETED ===');
  //     print('Generated ${generatedTechPackImages.length} tech pack images');

  //     Get.snackbar(
  //       'Success',
  //       'Tech pack images generated successfully with your specifications!',
  //       snackPosition: SnackPosition.TOP,
  //       backgroundColor: Colors.green,
  //       colorText: Colors.white,
  //     );
  //   } catch (e) {
  //     print('=== TECH PACK GENERATION ERROR ===');
  //     print('Error: $e');
      
  //     Get.snackbar(
  //       'Error',
  //       'Failed to generate tech pack images: ${e.toString()}',
  //       snackPosition: SnackPosition.TOP,
  //       backgroundColor: Colors.red,
  //       colorText: Colors.white,
  //     );
  //   } finally {
  //     isGeneratingTechPack.value = false;
  //   }
  // }

  // REPLACE YOUR EXISTING generateTechPackImages FUNCTION WITH THIS:
// Future<void> generateTechPackImages() async {
//   try {
//     print('=== STARTING ENHANCED TECH PACK GENERATION ===');
//     isGeneratingTechPack.value = true;
//     generatedTechPackImages.clear();

//     // Collect all tech pack details from form inputs
//     final techPackDetails = _collectTechPackDetails();
    
//     print('Tech Pack Details: $techPackDetails');
//     print('Design Data: $designData');
//     print('Selected Design Prompt: ${selectedDesignPrompt.value}');

//     // Generate optimized prompts directly (no GPT-4 API call)
//     print('Generating optimized prompts...');
//     final prompts = await OpenAIService.generateTechPackPrompts(
//       creativeBrief: designData['creativeBrief'] ?? {},
//       refinedConcept: designData['refinedConcept'] ?? {},
//       finalDetails: designData['finalDetails'] ?? {},
//       techPackDetails: techPackDetails,
//       selectedDesignPrompt: selectedDesignPrompt.value,
//     );
    
//     // Verify prompt lengths
//     print('Generated Manufacturing Prompt length: ${prompts['manufacturing_prompt']?.length ?? 0}');
//     print('Generated Technical Flat Prompt length: ${prompts['technical_flat_prompt']?.length ?? 0}');

//     // Generate manufacturing layout image
//     print('Generating manufacturing layout image...');
//     final manufacturingImages = await OpenAIService.generateDesignImages(
//       prompt: prompts['manufacturing_prompt'] ?? _generateFallbackManufacturingPrompt(),
//       numberOfImages: 1,
//       size: '1024x1024',
//     );

//     // Generate technical flat drawing image
//     print('Generating technical flat drawing image...');
//     final technicalImages = await OpenAIService.generateDesignImages(
//       prompt: prompts['technical_flat_prompt'] ?? _generateFallbackTechnicalPrompt(),
//       numberOfImages: 1,
//       size: '1024x1024',
//     );

//     generatedTechPackImages.addAll(manufacturingImages);
//     generatedTechPackImages.addAll(technicalImages);
    
//     print('=== ENHANCED TECH PACK GENERATION COMPLETED ===');
//     print('Generated ${generatedTechPackImages.length} tech pack images');

//     Get.snackbar(
//       'Success',
//       'Enhanced tech pack images generated successfully!',
//       snackPosition: SnackPosition.TOP,
//       backgroundColor: Colors.green,
//       colorText: Colors.white,
//     );
//   } catch (e) {
//     print('=== TECH PACK GENERATION ERROR ===');
//     print('Error: $e');
    
//     Get.snackbar(
//       'Error',
//       'Failed to generate tech pack images: ${e.toString()}',
//       snackPosition: SnackPosition.TOP,
//       backgroundColor: Colors.red,
//       colorText: Colors.white,
//     );
//   } finally {
//     isGeneratingTechPack.value = false;
//   }
// }

// // ADD THESE FALLBACK FUNCTIONS TO YOUR CLASS:
// String _generateFallbackManufacturingPrompt() {
//   final techPackDetails = _collectTechPackDetails();
//   final garmentType = designData['creativeBrief']?['garmentType'] ?? 'Jacket';
//   final primaryColor = techPackDetails['colors']?['primaryColor'] ?? 'cyan green';
//   final mainFabric = techPackDetails['materials']?['mainFabric'] ?? 'cotton';
  
//   return '''Professional tech pack specification sheet for ${garmentType.toLowerCase()}. Organized sections: MATERIALS (${mainFabric} with swatches), COLORS (${primaryColor} with color swatch), SIZES table, LABELS, PACKAGING, PRODUCTION details. White background, professional layout.''';
// }

// String _generateFallbackTechnicalPrompt() {
//   final techPackDetails = _collectTechPackDetails();
//   final garmentType = designData['creativeBrief']?['garmentType'] ?? 'Jacket';
//   final features = designData['refinedConcept']?['features'] ?? 'collar';
  
//   return '''Technical flat drawing ${garmentType.toLowerCase()} with ${features}. Black line art on white background. Front/back views with measurements, construction notes, dimension lines. Professional fashion flat drawing.''';
// }


Future<void> generateTechPackImages() async {
  try {
    print('=== STARTING DETAILED TECH PACK GENERATION ===');
    isGeneratingTechPack.value = true;
    generatedTechPackImages.clear();

    final techPackDetails = _collectTechPackDetails();
    
    print('Tech Pack Details: $techPackDetails');
    print('Design Data: $designData');

    // Try different prompt approaches in order of preference
    Map<String, String> prompts;
    String approach = '';

    try {
      // First attempt: Full detailed prompts with three views
      approach = 'Detailed Three Views';
      prompts = await OpenAIService.generateTechPackPrompts(
        creativeBrief: designData['creativeBrief'] ?? {},
        refinedConcept: designData['refinedConcept'] ?? {},
        finalDetails: designData['finalDetails'] ?? {},
        techPackDetails: techPackDetails,
        selectedDesignPrompt: selectedDesignPrompt.value,
      );
    } catch (e) {
      try {
        // Second attempt: Advanced detailed with explicit positioning
        approach = 'Advanced Detailed Layout';
        print('Trying advanced detailed prompts...');
        prompts = OpenAIService.getAdvancedDetailedPrompts(techPackDetails, designData['creativeBrief'] ?? {});
      } catch (e2) {
        try {
          // Third attempt: Detailed single view
          approach = 'Detailed Single View';
          print('Trying detailed single view prompts...');
          prompts = OpenAIService.getDetailedSingleViewPrompts(techPackDetails, designData['creativeBrief'] ?? {});
        } catch (e3) {
          // Final fallback: Simplified but detailed
          approach = 'Simplified Detailed';
          print('Using simplified detailed prompts...');
          prompts = OpenAIService.getSimplifiedDetailedPrompts(techPackDetails, designData['creativeBrief'] ?? {});
        }
      }
    }
    
    print('Using approach: $approach');
    print('Manufacturing Prompt: ${prompts['manufacturing_prompt']}');
    print('Technical Prompt: ${prompts['technical_flat_prompt']}');

    // Generate manufacturing layout image
    print('Generating manufacturing layout image...');
    List<String> manufacturingImages = [];
    try {
      manufacturingImages = await OpenAIService.generateDesignImages(
        prompt: prompts['manufacturing_prompt'] ?? '',
        numberOfImages: 1,
        size: '1024x1024',
      );
      print('‚úÖ Manufacturing image generated successfully');
    } catch (e) {
      print('‚ùå Manufacturing image generation failed: $e');
      throw Exception('Failed to generate manufacturing image');
    }

    // Generate technical flat drawing with detailed approach
    print('Generating detailed technical flat drawing...');
    List<String> technicalImages = [];
    try {
      technicalImages = await OpenAIService.generateDesignImages(
        prompt: prompts['technical_flat_prompt'] ?? '',
        numberOfImages: 1,
        size: '1024x1024', // Try 1024x1792 for vertical if 1024x1024 cuts off
      );
      print('‚úÖ Technical flat drawing generated successfully');
    } catch (e) {
      print('‚ùå Technical image generation failed, trying fallback: $e');
      
      // Fallback with even simpler prompt
      final fallbackPrompt = 'Technical flat drawing of garment, front view, black lines on white background. Include measurement labels A, B, C, D and construction details. Complete drawing centered with margins.';
      technicalImages = await OpenAIService.generateDesignImages(
        prompt: fallbackPrompt,
        numberOfImages: 1,
        size: '1024x1024',
      );
    }

    // Add images to the list
    generatedTechPackImages.addAll(manufacturingImages);
    generatedTechPackImages.addAll(technicalImages);
    
    print('=== DETAILED TECH PACK GENERATION COMPLETED ===');
    print('Generated ${generatedTechPackImages.length} tech pack images using: $approach');

    // Validate and provide feedback
    if (generatedTechPackImages.length >= 2) {
      print('‚úÖ Both manufacturing and detailed technical images generated successfully');
      Get.snackbar(
        'Success',
        'Detailed tech pack images generated with professional labeling!',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } else {
      print('‚ö†Ô∏è Warning: Only ${generatedTechPackImages.length} images generated');
      Get.snackbar(
        'Partial Success',
        'Some tech pack images generated. Check results.',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.orange,
        colorText: Colors.white,
      );
    }
  } catch (e) {
    print('=== TECH PACK GENERATION ERROR ===');
    print('Error: $e');
    
    Get.snackbar(
      'Error',
      'Failed to generate detailed tech pack images: ${e.toString()}',
      snackPosition: SnackPosition.TOP,
      backgroundColor: Colors.red,
      colorText: Colors.white,
    );
  } finally {
    isGeneratingTechPack.value = false;
  }
}

// Add this function to test different technical drawing approaches
void testTechnicalDrawingPrompts() {
  final techPackDetails = _collectTechPackDetails();
  final creativeBrief = designData['creativeBrief'] ?? {};
  
  print('=== TESTING TECHNICAL DRAWING PROMPTS ===');
  
  // Test detailed three views
  final detailed = OpenAIService.getAdvancedDetailedPrompts(techPackDetails, creativeBrief);
  print('Advanced Detailed: ${detailed['technical_flat_prompt']}');
  
  // Test single detailed view
  final singleView = OpenAIService.getDetailedSingleViewPrompts(techPackDetails, creativeBrief);
  print('Single Detailed: ${singleView['technical_flat_prompt']}');
  
  // Test simplified detailed
  final simplified = OpenAIService.getSimplifiedDetailedPrompts(techPackDetails, creativeBrief);
  print('Simplified Detailed: ${simplified['technical_flat_prompt']}');
}

  // Camera functionality
  Future<void> openCameraForMeasurement() async {
    try {
      // Request camera permission
      PermissionStatus cameraStatus = await Permission.camera.request();
      
      if (cameraStatus.isGranted) {
        final XFile? photo = await _picker.pickImage(
          source: ImageSource.camera,
          imageQuality: 80,
          preferredCameraDevice: CameraDevice.rear,
        );
        
        if (photo != null) {
          measurementImagePath.value = photo.path;
          // Check if sizes block should be shown after image capture
          checkSizesBlockComplete();
        }
      } else if (cameraStatus.isDenied) {
        Get.snackbar(
          'Permission Required',
          'Camera permission is required to take photos.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.orange,
          colorText: Colors.white,
        );
      } else if (cameraStatus.isPermanentlyDenied) {
        Get.snackbar(
          'Permission Denied',
          'Camera permission is permanently denied. Please enable it in app settings.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.red,
          colorText: Colors.white,
          mainButton: TextButton(
            onPressed: () => openAppSettings(),
            child: const Text('Settings', style: TextStyle(color: Color.fromARGB(255, 236, 236, 236))),
          ),
        );
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to open camera: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Optional: Method to pick from gallery as alternative
  Future<void> pickImageFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 80,
      );
      
      if (image != null) {
        measurementImagePath.value = image.path;
        checkSizesBlockComplete();
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to pick image: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Collect all current tech pack details from form inputs
  Map<String, dynamic> _collectTechPackDetails() {
    return {
      'materials': {
        'mainFabric': mainFabricController.text,
        'secondaryMaterials': secondaryMaterialsController.text,
        'fabricProperties': fabricPropertiesController.text,
      },
      'colors': {
        'primaryColor': primaryColorController.text,
        'alternateColorways': alternateColorwaysController.text,
        'pantone': pantoneController.text,
      },
      'sizes': {
        'sizeRange': sizeRangeController.text,
        'measurementChart': measurementChartController.text,
        'measurementImage': measurementImagePath.value,
      },
      'technical': {
        'accessories': accessoriesController.text,
        'stitching': stitchingController.text,
        'decorativeStitching': decorativeStitchingController.text,
      },
      'labeling': {
        'logoPlacement': logoPlacementController.text,
        'labelsNeeded': labelsNeededController.text,
        'qrCode': qrCodeController.text,
      },
      'packaging': {
        'packagingType': packagingTypeController.text,
        'foldingInstructions': foldingInstructionsController.text,
        'inserts': insertsController.text,
      },
      'production': {
        'costPerPiece': costPerPieceController.text,
        'quantity': quantityController.text,
        'deliveryDate': deliveryDateController.text,
      },
    };
  }

  @override
  void onClose() {
    mainFabricController.dispose();
    secondaryMaterialsController.dispose();
    fabricPropertiesController.dispose();
    primaryColorController.dispose();
    alternateColorwaysController.dispose();
    pantoneController.dispose();
    sizeRangeController.dispose();
    measurementChartController.dispose();
    accessoriesController.dispose();
    stitchingController.dispose();
    decorativeStitchingController.dispose();
    logoPlacementController.dispose();
    labelsNeededController.dispose();
    qrCodeController.dispose();
    packagingTypeController.dispose();
    foldingInstructionsController.dispose();
    insertsController.dispose();
    costPerPieceController.dispose();
    quantityController.dispose();
    deliveryDateController.dispose();
    super.onClose();
  }
}

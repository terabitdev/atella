import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../firebase/api/openai_service.dart';

class TechPackDetailsController extends GetxController {
  // Materials & Fabrics
  final mainFabricController = TextEditingController();
  final secondaryMaterialsController = TextEditingController();
  final fabricPropertiesController = TextEditingController();

  // Colors
  final primaryColorController = TextEditingController();
  final alternateColorwaysController = TextEditingController();
  final pantoneController = TextEditingController();

  // Sizes & Measurements
  final sizeRangeController = TextEditingController();
  final measurementChartController = TextEditingController();
  final autogeneratedController = TextEditingController();
  final RxString measurementImagePath = ''.obs;

  // Technical Details
  final accessoriesController = TextEditingController();
  final stitchingController = TextEditingController();
  final decorativeStitchingController = TextEditingController();

  // Labeling & Branding
  final logoPlacementController = TextEditingController();
  final labelsNeededController = TextEditingController();
  final qrCodeController = TextEditingController();

  // Packaging & Shipping
  final packagingTypeController = TextEditingController();
  final foldingInstructionsController = TextEditingController();
  final insertsController = TextEditingController();

  // Production Details
  final costPerPieceController = TextEditingController();
  final quantityController = TextEditingController();
  final deliveryDateController = TextEditingController();

  // Block visibility
  final RxBool showColorsBlock = false.obs;
  final RxBool showSizesBlock = false.obs;
  final RxBool showTechnicalBlock = false.obs;
  final RxBool showLabelingBlock = false.obs;
  final RxBool showPackagingBlock = false.obs;
  final RxBool showProductionBlock = false.obs;

  // Image picker instance
  final ImagePicker _picker = ImagePicker();

  // Tech pack generation state
  final RxBool isGeneratingTechPack = false.obs;
  final RxList<String> generatedTechPackImages = <String>[].obs;
  final RxString selectedDesignImagePath = ''.obs;

  void checkMaterialsBlockComplete() {
    if (mainFabricController.text.isNotEmpty &&
        secondaryMaterialsController.text.isNotEmpty &&
        fabricPropertiesController.text.isNotEmpty) {
      showColorsBlock.value = true;
    }
  }

  void checkColorsBlockComplete() {
    if (primaryColorController.text.isNotEmpty &&
        alternateColorwaysController.text.isNotEmpty &&
        pantoneController.text.isNotEmpty) {
      showSizesBlock.value = true;
    }
  }

  void checkSizesBlockComplete() {
    if (sizeRangeController.text.isNotEmpty &&
        measurementChartController.text.isNotEmpty) {
      showTechnicalBlock.value = true;
    }
  }

  void checkTechnicalBlockComplete() {
    if (accessoriesController.text.isNotEmpty &&
        stitchingController.text.isNotEmpty &&
        decorativeStitchingController.text.isNotEmpty) {
      showLabelingBlock.value = true;
    }
  }

  void checkLabelingBlockComplete() {
    if (logoPlacementController.text.isNotEmpty &&
        labelsNeededController.text.isNotEmpty &&
        qrCodeController.text.isNotEmpty) {
      showPackagingBlock.value = true;
    }
  }

  void checkPackagingBlockComplete() {
    if (packagingTypeController.text.isNotEmpty &&
        foldingInstructionsController.text.isNotEmpty &&
        insertsController.text.isNotEmpty) {
      showProductionBlock.value = true;
    }
  }

  void checkProductionBlockComplete() {
    // No further block, but could trigger a summary or enable submit
  }

  String _generateTechPackPrompt() {
    return '''
Analyze the garment image and generate a full manufacturing tech pack. Include: materials, Pantone-referenced colors, size chart (${sizeRangeController.text.isNotEmpty ? sizeRangeController.text : 'XS‚ÄìXXL'}), construction, hardware, labeling, packaging, and production costs. Use the details below:

üß∂ Materials: ${mainFabricController.text.isNotEmpty ? mainFabricController.text : 'Organic cotton'} / ${secondaryMaterialsController.text.isNotEmpty ? secondaryMaterialsController.text : 'Polyester blend'}; ${fabricPropertiesController.text.isNotEmpty ? fabricPropertiesController.text : 'pre-shrunk, brushed interior'}.

üé® Colors: ${primaryColorController.text.isNotEmpty ? primaryColorController.text : 'Primary color'} (${pantoneController.text.isNotEmpty ? pantoneController.text : 'Pantone reference needed'}); alternates: ${alternateColorwaysController.text.isNotEmpty ? alternateColorwaysController.text : 'Alternative colors'}.

üìè Sizes: ${sizeRangeController.text.isNotEmpty ? sizeRangeController.text : 'XS‚ÄìXXL'}, ${measurementChartController.text.isNotEmpty ? measurementChartController.text : 'standard fit chart'}.

ü™° Details: ${accessoriesController.text.isNotEmpty ? accessoriesController.text : 'Standard hardware'}, ${stitchingController.text.isNotEmpty ? stitchingController.text : 'reinforced seams'}, ${decorativeStitchingController.text.isNotEmpty ? decorativeStitchingController.text : 'standard stitching'}.

üè∑Ô∏è Labels: ${logoPlacementController.text.isNotEmpty ? logoPlacementController.text : 'Logo placement'}, ${labelsNeededController.text.isNotEmpty ? labelsNeededController.text : 'standard labels'}, ${qrCodeController.text.isNotEmpty ? qrCodeController.text : 'product tracking'}.

üì¶ Packaging: ${packagingTypeController.text.isNotEmpty ? packagingTypeController.text : 'Standard packaging'}, ${foldingInstructionsController.text.isNotEmpty ? foldingInstructionsController.text : 'fold instructions'}, ${insertsController.text.isNotEmpty ? insertsController.text : 'product inserts'}.

üí∏ Costs: ${costPerPieceController.text.isNotEmpty ? costPerPieceController.text : 'Cost estimate'}, ${quantityController.text.isNotEmpty ? quantityController.text : 'production quantity'}, ${deliveryDateController.text.isNotEmpty ? deliveryDateController.text : 'delivery timeline'}.
    '''.trim();
  }

  String _generateTechnicalFlatPrompt() {
    return '''
Create a technical fashion flat drawing tech pack for the garment. Generate professional black and white line drawings showing:

VIEWS: Front/back technical flats with construction callouts, side view showing pockets
ANNOTATIONS with leader lines: Measurements, ${accessoriesController.text.isNotEmpty ? accessoriesController.text : 'hardware'} spacing, pocket placement, sleeve/cuff details, seam construction, hem details, ${stitchingController.text.isNotEmpty ? stitchingController.text : 'topstitching'} specs, stitch types
SPECIFICATIONS: All measurements in cm, stitch types (single/double needle), seam details, ${decorativeStitchingController.text.isNotEmpty ? decorativeStitchingController.text : 'construction'} methods

TEXT REQUIREMENTS: Use large, bold, clear sans-serif font. High contrast black text on white background. Ensure ALL text labels are complete words, fully visible, and positioned with adequate spacing from image edges. No text should be cut off or truncated. Maintain minimum 1cm spacing between labels.

STYLE: Professional apparel manufacturing tech pack aesthetic - clean technical line work with annotation callouts and leader lines. Avoid photorealistic rendering, focus on technical sketch style used in garment production.

LAYOUT: Prominent front/back views with detailed technical callouts surrounding flats, similar to professional manufacturing tech pack layouts. Ensure all annotations fit completely within image boundaries.
    '''.trim();
  }

  Future<void> generateTechPackImages() async {
    try {
      isGeneratingTechPack.value = true;
      generatedTechPackImages.clear();

      final techPackPrompt = _generateTechPackPrompt();
      final technicalFlatPrompt = _generateTechnicalFlatPrompt();

      final techPackImages = await OpenAIService.generateDesignImages(
        prompt: techPackPrompt,
        numberOfImages: 1,
        size: '1024x1024',
      );

      final technicalImages = await OpenAIService.generateDesignImages(
        prompt: technicalFlatPrompt,
        numberOfImages: 1,
        size: '1024x1024',
      );

      generatedTechPackImages.addAll(techPackImages);
      generatedTechPackImages.addAll(technicalImages);

      Get.snackbar(
        'Success',
        'Tech pack images generated successfully!',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to generate tech pack images: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    } finally {
      isGeneratingTechPack.value = false;
    }
  }

  // Camera functionality
  Future<void> openCameraForMeasurement() async {
    try {
      // Request camera permission
      PermissionStatus cameraStatus = await Permission.camera.request();
      
      if (cameraStatus.isGranted) {
        final XFile? photo = await _picker.pickImage(
          source: ImageSource.camera,
          imageQuality: 80,
          preferredCameraDevice: CameraDevice.rear,
        );
        
        if (photo != null) {
          measurementImagePath.value = photo.path;
          // Check if sizes block should be shown after image capture
          checkSizesBlockComplete();
        }
      } else if (cameraStatus.isDenied) {
        Get.snackbar(
          'Permission Required',
          'Camera permission is required to take photos.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.orange,
          colorText: Colors.white,
        );
      } else if (cameraStatus.isPermanentlyDenied) {
        Get.snackbar(
          'Permission Denied',
          'Camera permission is permanently denied. Please enable it in app settings.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.red,
          colorText: Colors.white,
          mainButton: TextButton(
            onPressed: () => openAppSettings(),
            child: const Text('Settings', style: TextStyle(color: Color.fromARGB(255, 236, 236, 236))),
          ),
        );
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to open camera: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Optional: Method to pick from gallery as alternative
  Future<void> pickImageFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 80,
      );
      
      if (image != null) {
        measurementImagePath.value = image.path;
        checkSizesBlockComplete();
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to pick image: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  @override
  void onClose() {
    mainFabricController.dispose();
    secondaryMaterialsController.dispose();
    fabricPropertiesController.dispose();
    primaryColorController.dispose();
    alternateColorwaysController.dispose();
    pantoneController.dispose();
    sizeRangeController.dispose();
    measurementChartController.dispose();
    accessoriesController.dispose();
    stitchingController.dispose();
    decorativeStitchingController.dispose();
    logoPlacementController.dispose();
    labelsNeededController.dispose();
    qrCodeController.dispose();
    packagingTypeController.dispose();
    foldingInstructionsController.dispose();
    insertsController.dispose();
    costPerPieceController.dispose();
    quantityController.dispose();
    deliveryDateController.dispose();
    super.onClose();
  }
}

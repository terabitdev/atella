import 'package:atella/core/themes/app_fonts.dart';
import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../Data/api/openai_service.dart';
import '../../../Data/Models/tech_pack_model.dart';
import '../../../Data/Models/user_subscription.dart';
import '../../../services/firebase/edit/edit_data_service.dart';
import '../../../services/PaymentService/stripe_subscription_service.dart';
import '../../../services/PaymentService/subscription_callback_service.dart';

class TechPackDetailsController extends GetxController {
  final EditDataService _editDataService = EditDataService();
  final StripeSubscriptionService _subscriptionService =
      StripeSubscriptionService();

  // Edit mode tracking
  final RxBool _isEditMode = false.obs;
  bool get isEditMode => _isEditMode.value;
  TechPackModel? _editingTechPack;
  // Materials & Fabrics
  final mainFabricController = TextEditingController();
  final secondaryMaterialsController = TextEditingController();
  final fabricPropertiesController = TextEditingController();

  // Colors
  final primaryColorController = TextEditingController();
  final alternateColorwaysController = TextEditingController();
  final pantoneController = TextEditingController();

  // Sizes & Measurements
  final sizeRangeController = TextEditingController();
  final measurementChartController = TextEditingController();
  final autogeneratedController = TextEditingController();
  final RxString measurementImagePath = ''.obs;

  // Technical Details
  final accessoriesController = TextEditingController();
  final stitchingController = TextEditingController();
  final decorativeStitchingController = TextEditingController();

  // Labeling & Branding
  final logoPlacementController = TextEditingController();
  final labelsNeededController = TextEditingController();
  final qrCodeController = TextEditingController();

  // Packaging & Shipping
  final packagingTypeController = TextEditingController();
  final foldingInstructionsController = TextEditingController();
  final insertsController = TextEditingController();

  // Production Details
  final costPerPieceController = TextEditingController();
  final quantityController = TextEditingController();
  final deliveryDateController = TextEditingController();

  // Block visibility
  final RxBool showColorsBlock = false.obs;
  final RxBool showSizesBlock = false.obs;
  final RxBool showTechnicalBlock = false.obs;
  final RxBool showLabelingBlock = false.obs;
  final RxBool showPackagingBlock = false.obs;
  final RxBool showProductionBlock = false.obs;

  // Image picker instance
  final ImagePicker _picker = ImagePicker();

  // Tech pack generation state
  final RxBool isGeneratingTechPack = false.obs;
  final RxList<String> generatedTechPackImages = <String>[].obs;
  final RxString selectedDesignImagePath = ''.obs;
  final RxString selectedDesignPrompt = ''.obs;
  Map<String, dynamic> designData = {};

  TechPackModel? get editingTechPack => _editingTechPack;

  @override
  void onInit() {
    super.onInit();
    _initializeWithArguments();
  }

  @override
  void onReady() {
    super.onReady();
    // Clear any pending callbacks to prevent disposed controller issues
    SubscriptionCallbackService().clearCallback();
  }

  void _initializeWithArguments() {
    // Get arguments passed from generate tech pack screen
    final arguments = Get.arguments as Map<String, dynamic>?;
    if (arguments != null) {
      selectedDesignImagePath.value = arguments['selectedDesignUrl'] ?? '';
      selectedDesignPrompt.value = arguments['designPrompt'] ?? '';
      designData = arguments['designData'] ?? {};

      // Check for edit mode
      final isEditMode = arguments['editMode'] == true;
      if (isEditMode) {
        _isEditMode.value = true;
        _editingTechPack = arguments['techPackModel'] as TechPackModel?;
        print('Tech Pack Details: Edit mode detected');
        _loadExistingTechPackData();
      }

      print('Tech Pack Details initialized with:');
      final imagePathPreview = selectedDesignImagePath.value.isNotEmpty
          ? selectedDesignImagePath.value.length > 50
                ? '${selectedDesignImagePath.value.substring(0, 50)}...'
                : selectedDesignImagePath.value
          : 'No image path';
      print('Design Image: $imagePathPreview');
      print('Design Prompt: ${selectedDesignPrompt.value}');
      print('Design Data: $designData');
      print('Edit Mode: $isEditMode');
    }
  }

  Future<void> _loadExistingTechPackData() async {
    if (_editingTechPack == null) return;

    try {
      print('Loading existing tech pack data for: ${_editingTechPack!.id}');

      // Get complete edit data from Firebase
      final editData = await _editDataService.getTechPackEditData(
        _editingTechPack!.id,
      );

      if (editData != null) {
        final techPackDetails =
            editData['techPackDetails'] as Map<String, dynamic>;
        if (techPackDetails.isNotEmpty) {
          final parsedDetails = _editDataService.parseTechPackDetailsForEdit(
            techPackDetails,
          );
          _populateTechPackFields(parsedDetails);

          // Show all blocks in edit mode
          _showAllBlocks();

          Get.snackbar(
            'Edit Mode',
            'Loading existing tech pack data...',
            backgroundColor: Colors.black,
            colorText: Colors.white,
            snackPosition: SnackPosition.TOP,
            duration: Duration(seconds: 3),
          );
        }
      }
    } catch (e) {
      print('Error loading tech pack data: $e');
      Get.snackbar(
        'Notice',
        'Starting with empty tech pack form',
        backgroundColor: Colors.black,
        snackPosition: SnackPosition.TOP,
        colorText: Colors.white,
      );
    }
  }

  void _populateTechPackFields(Map<String, dynamic> techPackDetails) {
    print('Populating tech pack fields with: $techPackDetails');

    // Materials & Fabrics
    final materials =
        techPackDetails['materials'] as Map<String, dynamic>? ?? {};
    mainFabricController.text = materials['mainFabric'] ?? '';
    secondaryMaterialsController.text = materials['secondaryMaterials'] ?? '';
    fabricPropertiesController.text = materials['fabricProperties'] ?? '';

    // Colors
    final colors = techPackDetails['colors'] as Map<String, dynamic>? ?? {};
    primaryColorController.text = colors['primaryColor'] ?? '';
    alternateColorwaysController.text = colors['alternateColorways'] ?? '';
    pantoneController.text = colors['pantone'] ?? '';

    // Sizes & Measurements
    final sizes = techPackDetails['sizes'] as Map<String, dynamic>? ?? {};
    sizeRangeController.text = sizes['sizeRange'] ?? '';
    measurementChartController.text = sizes['measurementChart'] ?? '';
    measurementImagePath.value = sizes['measurementImage'] ?? '';

    // Technical Details
    final technical =
        techPackDetails['technical'] as Map<String, dynamic>? ?? {};
    accessoriesController.text = technical['accessories'] ?? '';
    stitchingController.text = technical['stitching'] ?? '';
    decorativeStitchingController.text = technical['decorativeStitching'] ?? '';

    // Labeling & Branding
    final labeling = techPackDetails['labeling'] as Map<String, dynamic>? ?? {};
    logoPlacementController.text = labeling['logoPlacement'] ?? '';
    labelsNeededController.text = labeling['labelsNeeded'] ?? '';
    qrCodeController.text = labeling['qrCode'] ?? '';

    // Packaging & Shipping
    final packaging =
        techPackDetails['packaging'] as Map<String, dynamic>? ?? {};
    packagingTypeController.text = packaging['packagingType'] ?? '';
    foldingInstructionsController.text = packaging['foldingInstructions'] ?? '';
    insertsController.text = packaging['inserts'] ?? '';

    // Production Details
    final production =
        techPackDetails['production'] as Map<String, dynamic>? ?? {};
    costPerPieceController.text = production['costPerPiece'] ?? '';
    quantityController.text = production['quantity'] ?? '';
    deliveryDateController.text = production['deliveryDate'] ?? '';

    update();
  }

  void _showAllBlocks() {
    // In edit mode, show all blocks
    showColorsBlock.value = true;
    showSizesBlock.value = true;
    showTechnicalBlock.value = true;
    showLabelingBlock.value = true;
    showPackagingBlock.value = true;
    showProductionBlock.value = true;
  }

  String _extractGarmentType() {
    // Extract garment type from the design prompt and data
    String garmentType = 'garment';

    if (designData.isNotEmpty) {
      final creativeBrief =
          designData['creativeBrief'] as Map<String, dynamic>?;
      if (creativeBrief != null && creativeBrief['garmentType'] != null) {
        garmentType = creativeBrief['garmentType'].toString().toLowerCase();
      }
    }

    // Fallback to analyzing the prompt
    if (garmentType == 'garment' && selectedDesignPrompt.value.isNotEmpty) {
      final prompt = selectedDesignPrompt.value.toLowerCase();
      if (prompt.contains('jacket') || prompt.contains('coat')) {
        garmentType = 'jacket';
      } else if (prompt.contains('dress')) {
        garmentType = 'dress';
      } else if (prompt.contains('shirt') || prompt.contains('blouse')) {
        garmentType = 'shirt';
      } else if (prompt.contains('pants') || prompt.contains('trousers')) {
        garmentType = 'pants';
      } else if (prompt.contains('skirt')) {
        garmentType = 'skirt';
      } else if (prompt.contains('hoodie') || prompt.contains('sweatshirt')) {
        garmentType = 'hoodie';
      }
    }

    return garmentType;
  }

  void checkMaterialsBlockComplete() {
    if (mainFabricController.text.isNotEmpty &&
        secondaryMaterialsController.text.isNotEmpty &&
        fabricPropertiesController.text.isNotEmpty) {
      showColorsBlock.value = true;
    }
  }

  void checkColorsBlockComplete() {
    if (primaryColorController.text.isNotEmpty &&
        alternateColorwaysController.text.isNotEmpty &&
        pantoneController.text.isNotEmpty) {
      showSizesBlock.value = true;
    }
  }

  void checkSizesBlockComplete() {
    if (sizeRangeController.text.isNotEmpty &&
        measurementChartController.text.isNotEmpty) {
      showTechnicalBlock.value = true;
    }
  }

  void checkTechnicalBlockComplete() {
    if (accessoriesController.text.isNotEmpty &&
        stitchingController.text.isNotEmpty &&
        decorativeStitchingController.text.isNotEmpty) {
      showLabelingBlock.value = true;
    }
  }

  void checkLabelingBlockComplete() {
    if (logoPlacementController.text.isNotEmpty &&
        labelsNeededController.text.isNotEmpty &&
        qrCodeController.text.isNotEmpty) {
      showPackagingBlock.value = true;
    }
  }

  void checkPackagingBlockComplete() {
    if (packagingTypeController.text.isNotEmpty &&
        foldingInstructionsController.text.isNotEmpty &&
        insertsController.text.isNotEmpty) {
      showProductionBlock.value = true;
    }
  }

  void checkProductionBlockComplete() {
    // No further block, but could trigger a summary or enable submit
  }

  Future<void> generateTechPackImages() async {
    // Subscription check is now handled by checkSubscriptionAndGenerate method
    // This method only handles the actual generation

    try {
      print('=== STARTING DETAILED TECH PACK GENERATION ===');
      isGeneratingTechPack.value = true;
      generatedTechPackImages.clear();

      final techPackDetails = _collectTechPackDetails();

      print('Tech Pack Details: $techPackDetails');
      print('Design Data: $designData');

      // Try different prompt approaches in order of preference
      Map<String, String> prompts;
      String approach = '';

      try {
        // First attempt: Full detailed prompts with three views
        approach = 'Detailed Three Views';
        prompts = await OpenAIService.generateTechPackPrompts(
          creativeBrief: designData['creativeBrief'] ?? {},
          refinedConcept: designData['refinedConcept'] ?? {},
          finalDetails: designData['finalDetails'] ?? {},
          techPackDetails: techPackDetails,
          selectedDesignPrompt: selectedDesignPrompt.value,
        );
      } catch (e) {
        try {
          // Second attempt: Advanced detailed with explicit positioning
          approach = 'Advanced Detailed Layout';
          print('Trying advanced detailed prompts...');
          prompts = OpenAIService.getAdvancedDetailedPrompts(
            techPackDetails,
            designData['creativeBrief'] ?? {},
          );
        } catch (e2) {
          try {
            // Third attempt: Detailed single view
            approach = 'Detailed Single View';
            print('Trying detailed single view prompts...');
            prompts = OpenAIService.getDetailedSingleViewPrompts(
              techPackDetails,
              designData['creativeBrief'] ?? {},
            );
          } catch (e3) {
            // Final fallback: Simplified but detailed
            approach = 'Simplified Detailed';
            print('Using simplified detailed prompts...');
            prompts = OpenAIService.getSimplifiedDetailedPrompts(
              techPackDetails,
              designData['creativeBrief'] ?? {},
            );
          }
        }
      }

      print('Using approach: $approach');
      print('Manufacturing Prompt: ${prompts['manufacturing_prompt']}');
      print('Technical Prompt: ${prompts['technical_flat_prompt']}');

      // Generate manufacturing layout image
      print('Generating manufacturing layout image...');
      List<String> manufacturingImages = [];
      try {
        manufacturingImages = await OpenAIService.generateDesignImages(
          prompt: prompts['manufacturing_prompt'] ?? '',
          numberOfImages: 1,
          size: '1024x1024',
        );
        print('✅ Manufacturing image generated successfully');
      } catch (e) {
        print('❌ Manufacturing image generation failed: $e');
        throw Exception('Failed to generate manufacturing image');
      }

      // Generate technical flat drawing with detailed approach
      print('Generating detailed technical flat drawing...');
      List<String> technicalImages = [];
      try {
        technicalImages = await OpenAIService.generateDesignImages(
          prompt: prompts['technical_flat_prompt'] ?? '',
          numberOfImages: 1,
          size: '1024x1024', // Try 1024x1792 for vertical if 1024x1024 cuts off
        );
        print('✅ Technical flat drawing generated successfully');
      } catch (e) {
        print('❌ Technical image generation failed, trying fallback: $e');

        // Fallback with even simpler prompt
        final fallbackPrompt =
            'Technical flat drawing of garment, front view, black lines on white background. Include measurement labels A, B, C, D and construction details. Complete drawing centered with margins.';
        technicalImages = await OpenAIService.generateDesignImages(
          prompt: fallbackPrompt,
          numberOfImages: 1,
          size: '1024x1024',
        );
      }

      // Add images to the list
      generatedTechPackImages.addAll(manufacturingImages);
      generatedTechPackImages.addAll(technicalImages);

      print('=== DETAILED TECH PACK GENERATION COMPLETED ===');
      print(
        'Generated ${generatedTechPackImages.length} tech pack images using: $approach',
      );

      // Increment techpack usage for STARTER plan users after successful generation
      await _subscriptionService.incrementTechpackUsage();

      // Validate and provide feedback
      if (generatedTechPackImages.length >= 2) {
        print(
          '✅ Both manufacturing and detailed technical images generated successfully',
        );
        Get.snackbar(
          'Success',
          'Detailed tech pack images generated with professional labeling!',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.black,
          colorText: Colors.white,
        );
      } else {
        print(
          '⚠️ Warning: Only ${generatedTechPackImages.length} images generated',
        );
        Get.snackbar(
          'Partial Success',
          'Some tech pack images generated. Check results.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.black,
          colorText: Colors.white,
        );
      }
    } catch (e) {
      print('=== TECH PACK GENERATION ERROR ===');
      print('Error: $e');

      Get.snackbar(
        'Error',
        'Failed to generate detailed tech pack images: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    } finally {
      isGeneratingTechPack.value = false;
    }
  }

  // Add this function to test different technical drawing approaches
  void testTechnicalDrawingPrompts() {
    final techPackDetails = _collectTechPackDetails();
    final creativeBrief = designData['creativeBrief'] ?? {};

    print('=== TESTING TECHNICAL DRAWING PROMPTS ===');

    // Test detailed three views
    final detailed = OpenAIService.getAdvancedDetailedPrompts(
      techPackDetails,
      creativeBrief,
    );
    print('Advanced Detailed: ${detailed['technical_flat_prompt']}');

    // Test single detailed view
    final singleView = OpenAIService.getDetailedSingleViewPrompts(
      techPackDetails,
      creativeBrief,
    );
    print('Single Detailed: ${singleView['technical_flat_prompt']}');

    // Test simplified detailed
    final simplified = OpenAIService.getSimplifiedDetailedPrompts(
      techPackDetails,
      creativeBrief,
    );
    print('Simplified Detailed: ${simplified['technical_flat_prompt']}');
  }

  // Camera functionality
  Future<void> openCameraForMeasurement() async {
    try {
      // Request camera permission
      PermissionStatus cameraStatus = await Permission.camera.request();

      if (cameraStatus.isGranted) {
        final XFile? photo = await _picker.pickImage(
          source: ImageSource.camera,
          imageQuality: 80,
          preferredCameraDevice: CameraDevice.rear,
        );

        if (photo != null) {
          measurementImagePath.value = photo.path;
          // Check if sizes block should be shown after image capture
          checkSizesBlockComplete();
        }
      } else if (cameraStatus.isDenied) {
        Get.snackbar(
          'Permission Required',
          'Camera permission is required to take photos.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.black,
          colorText: Colors.white,
        );
      } else if (cameraStatus.isPermanentlyDenied) {
        Get.snackbar(
          'Permission Denied',
          'Camera permission is permanently denied. Please enable it in app settings.',
          snackPosition: SnackPosition.TOP,
          backgroundColor: Colors.red,
          colorText: Colors.white,
          mainButton: TextButton(
            onPressed: () => openAppSettings(),
            child: const Text(
              'Settings',
              style: TextStyle(color: Color.fromARGB(255, 236, 236, 236)),
            ),
          ),
        );
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to open camera: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  // Optional: Method to pick from gallery as alternative
  Future<void> pickImageFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 80,
      );

      if (image != null) {
        measurementImagePath.value = image.path;
        checkSizesBlockComplete();
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to pick image: ${e.toString()}',
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  Future<void> checkSubscriptionAndGenerate() async {
    // Check subscription before generating final techpack (with monthly reset check)
    bool canGenerate = await _subscriptionService.canUsePremiumFeatureWithReset('techpack');
    
    if (!canGenerate) {
      // Show upgrade prompt
      _showUpgradeDialog();
      return;
    }
    
    // If user has permission, start generation and navigate immediately
    generateTechPackImages(); // Don't await - let it run in background
    Get.toNamed('/tech_pack_ready_screen'); // Navigate immediately to show generating state
  }

  void _showUpgradeDialog() async {
    // Get current subscription to show in dialog
    final subscription = await _subscriptionService
        .getCurrentUserSubscription();
    String currentPlan = subscription?.subscriptionPlan ?? 'FREE';
    int remainingTechpacks = subscription?.remainingTechpacks ?? 3;

    // Show different dialogs based on plan
    if (currentPlan == 'FREE') {
      _showFreeUpgradeDialog(currentPlan);
    } else if (currentPlan == 'STARTER' || currentPlan == 'STARTER_YEARLY') {
      _showStarterLimitDialog(subscription);
    } else if (currentPlan == 'PRO' || currentPlan == 'PRO_YEARLY') {
      _showProLimitDialog(subscription);
    }
  }

  void _showFreeUpgradeDialog(String currentPlan) {
    Get.dialog(
      AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
        title: Row(
          children: [
            Text(
              'Upgrade Required',
              style: sfpsTitleTextTextStyle18600.copyWith(color: Colors.red),
            ),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Current plan info
            Container(
              width: double.infinity,
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.grey.shade300),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        'Current Plan: ',
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 12,
                          color: Colors.black,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        _getPlanDisplayName(currentPlan),
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                          color: Colors.black,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            SizedBox(height: 16),
            Text(
              'Final techpack generation requires a premium plan.',
              style: ssTitleTextTextStyle124003,
            ),
            SizedBox(height: 12),
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.white,
                border: Border.all(color: Colors.grey.shade300),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Upgrade to access:',
                    style: ssTitleTextTextStyle14400.copyWith(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                      color: Colors.black,
                    ),
                  ),
                  SizedBox(height: 8),
                  _buildFeatureItem('Generate final techpacks (3/month with Starter)'),
                  _buildFeatureItem('Professional PDF techpack exports'),
                  _buildFeatureItem('Access to manufacturer database'),
                ],
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: Text(
              'Maybe Later',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.black,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          ElevatedButton(
            onPressed: () {
              Get.back();
              
              // Set callback to refresh the UI state after subscription
              SubscriptionCallbackService().setOnSubscriptionSuccess(() {
                print('Subscription upgraded, TechPack UI refreshed');
              });

              // Navigate to subscription screen
              Get.toNamed(
                '/subscribe',
                arguments: {
                  'returnRoute': '/tech_pack_details_screen',
                  'showSuccessMessage': true,
                },
              );
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.black,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(24),
              ),
            ),
            child: Text(
              'Upgrade Now',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      barrierDismissible: false,
    );
  }

  void _showStarterLimitDialog(UserSubscription? subscription) {
    Get.dialog(
      AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
        title: Row(
          children: [
            Icon(
              Icons.warning_amber_rounded,
              color: Colors.red,
              size: 24,
            ),
            SizedBox(width: 8),
            Text(
              'Limit Exceeded',
              style: sfpsTitleTextTextStyle18600.copyWith(color: Colors.red),
            ),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Current plan info
            Container(
              width: double.infinity,
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.grey.shade300),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        'Current Plan: ',
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 12,
                          color: Colors.black,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        _getPlanDisplayName(subscription?.subscriptionPlan ?? 'STARTER'),
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                          color: Colors.black,
                        ),
                      ),
                    ],
                  ),
                  Padding(
                    padding: EdgeInsets.only(top: 4),
                    child: Text(
                      'limit reached: ${_getTechpacksUsed(subscription)}/${subscription?.totalAllowedTechpacks ?? 3} techpacks used this ${_getBillingPeriodText(subscription)}',
                      style: ssTitleTextTextStyle14400.copyWith(
                        fontSize: 12,
                        color: Colors.red.shade600,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(height: 16),
            Text(
              'You\'ve reached your limit of techpacks. Choose an option to continue:',
              style: ssTitleTextTextStyle124003,
            ),
            SizedBox(height: 16),
            // Extra techpacks option
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.white,
                border: Border.all(color: Colors.grey.shade300),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        '+5 Techpacks: €4.99',
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 14,
                          fontWeight: FontWeight.bold,
                          color: Colors.black,
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: 4),
                  Text(
                    'Get 5 additional techpacks for this ${_getBillingPeriodText(subscription)}',
                    style: ssTitleTextTextStyle14400.copyWith(
                      fontSize: 12,
                      color: Colors.black,
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(height: 8),
            // More techpacks option
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.white,
                border: Border.all(color: Colors.grey.shade300),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        '+10 Techpacks: €8.99',
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 14,
                          fontWeight: FontWeight.bold,
                          color: Colors.black,
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: 4),
                  Text(
                    'Get 10 additional techpacks for this ${_getBillingPeriodText(subscription)}',
                    style: ssTitleTextTextStyle14400.copyWith(
                      fontSize: 12,
                      color: Colors.black,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: Text(
              'Maybe Later',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.grey[600],
              ),
            ),
          ),
          TextButton(
            onPressed: () {
              Get.back();
              _purchaseExtraTechpacks(5, 4.99);
            },
            child: Text(
              '+5 Techpacks',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.black,
              ),
            ),
          ),
          TextButton(
            onPressed: () {
              Get.back();
              _purchaseExtraTechpacks(10, 8.99);
            },
            child: Text(
              '+10 Techpacks',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.black,
              ),
            ),
          ),
          ElevatedButton(
            onPressed: () {
              Get.back();
              
              // Set callback to refresh the UI state after subscription
              SubscriptionCallbackService().setOnSubscriptionSuccess(() {
                print('Subscription upgraded, TechPack UI refreshed');
              });

              // Navigate to subscription screen
              Get.toNamed(
                '/subscribe',
                arguments: {
                  'returnRoute': '/tech_pack_details_screen',
                  'showSuccessMessage': true,
                },
              );
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.black,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(24),
              ),
            ),
            child: Text(
              'Upgrade to Pro',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      barrierDismissible: false,
    );
  }

  void _showProLimitDialog(UserSubscription? subscription) {
    Get.dialog(
      AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
        title: Row(
          children: [
            Icon(
              Icons.warning_amber_rounded,
              color: Colors.purple,
              size: 24,
            ),
            SizedBox(width: 8),
            Text(
              '${_getBillingPeriodText(subscription).replaceFirstMapped(RegExp(r'^.'), (m) => m.group(0)!.toUpperCase())} Limit Reached',
              style: sfpsTitleTextTextStyle18600.copyWith(color: Colors.purple),
            ),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Current plan info
            Container(
              width: double.infinity,
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.purple.shade50,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.purple.shade200),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(Icons.star, color: Colors.purple, size: 16),
                      SizedBox(width: 4),
                      Text(
                        'Current Plan: ',
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 12,
                          color: Colors.black,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        _getPlanDisplayName(subscription?.subscriptionPlan ?? 'PRO'),
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                          color: Colors.purple,
                        ),
                      ),
                    ],
                  ),
                  Padding(
                    padding: EdgeInsets.only(top: 4),
                    child: Text(
                      'Monthly limit reached: ${subscription?.techpacksUsedThisMonth ?? 0}/${subscription?.totalAllowedTechpacks ?? 20} techpacks used',
                      style: ssTitleTextTextStyle14400.copyWith(
                        fontSize: 12,
                        color: Colors.red.shade600,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(height: 16),
            Text(
              'You\'ve reached your Pro plan monthly limit of ${subscription?.totalAllowedTechpacks ?? 20} techpacks. You can purchase additional techpacks to continue:',
              style: ssTitleTextTextStyle124003,
            ),
            SizedBox(height: 16),
            // Extra techpacks option
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.blue.shade50,
                border: Border.all(color: Colors.blue.shade200),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(Icons.add_circle, color: Colors.blue, size: 20),
                      SizedBox(width: 8),
                      Text(
                        '+5 Techpacks: €4.99',
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 14,
                          fontWeight: FontWeight.bold,
                          color: Colors.blue.shade700,
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: 4),
                  Text(
                    'Get 5 additional techpacks for this ${_getBillingPeriodText(subscription)}',
                    style: ssTitleTextTextStyle14400.copyWith(
                      fontSize: 12,
                      color: Colors.blue.shade600,
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(height: 8),
            // More techpacks option
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.green.shade50,
                border: Border.all(color: Colors.green.shade200),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(Icons.add_circle, color: Colors.green, size: 20),
                      SizedBox(width: 8),
                      Text(
                        '+10 Techpacks: €8.99',
                        style: ssTitleTextTextStyle14400.copyWith(
                          fontSize: 14,
                          fontWeight: FontWeight.bold,
                          color: Colors.green.shade700,
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: 4),
                  Text(
                    'Get 10 additional techpacks for this ${_getBillingPeriodText(subscription)}',
                    style: ssTitleTextTextStyle14400.copyWith(
                      fontSize: 12,
                      color: Colors.green.shade600,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: Text(
              'Maybe Later',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.grey[600],
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          TextButton(
            onPressed: () {
              Get.back();
              _purchaseExtraTechpacks(5, 4.99);
            },
            child: Text(
              '+5 Techpacks',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.blue,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          TextButton(
            onPressed: () {
              Get.back();
              _purchaseExtraTechpacks(10, 8.99);
            },
            child: Text(
              '+10 Techpacks',
              style: ssTitleTextTextStyle14400.copyWith(
                color: Colors.green,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      barrierDismissible: false,
    );
  }

  Future<void> _purchaseExtraTechpacks(int count, double price) async {
    try {
      Get.snackbar(
        'Processing',
        'Processing your purchase...',
        backgroundColor: Colors.blue,
        colorText: Colors.white,
        snackPosition: SnackPosition.TOP,
      );

      bool success = await _subscriptionService.purchaseExtraTechpacks(count, price);
      
      if (success) {
        // Get current subscription to show correct billing period
        final subscription = await _subscriptionService.getCurrentUserSubscription();
        String period = _getBillingPeriodText(subscription);
        
        Get.snackbar(
          'Success!',
          'You now have $count additional techpacks for this $period!',
          backgroundColor: Colors.green,
          colorText: Colors.white,
          snackPosition: SnackPosition.TOP,
          duration: Duration(seconds: 4),
        );
        
        // After successful purchase, allow user to generate techpack
        generateTechPackImages();
        Get.toNamed('/tech_pack_ready_screen');
      } else {
        Get.snackbar(
          'Purchase Failed',
          'Unable to process your purchase. Please try again.',
          backgroundColor: Colors.red,
          colorText: Colors.white,
          snackPosition: SnackPosition.TOP,
        );
      }
    } catch (e) {
      Get.snackbar(
        'Error',
        'An error occurred during purchase: ${e.toString()}',
        backgroundColor: Colors.red,
        colorText: Colors.white,
        snackPosition: SnackPosition.TOP,
      );
    }
  }

  String _getPlanDisplayName(String plan) {
    switch (plan) {
      case 'FREE':
        return 'Free';
      case 'STARTER':
        return 'Starter (€9.99/month)';
      case 'STARTER_YEARLY':
        return 'Starter (€99/year)';
      case 'PRO':
        return 'Pro (€24.99/month)';
      case 'PRO_YEARLY':
        return 'Pro (€249/year)';
      default:
        return 'Free';
    }
  }

  int _getTechpacksUsed(UserSubscription? subscription) {
    if (subscription == null) return 0;
    
    // Check if it's a yearly subscription
    bool isYearly = subscription.billingPeriod == 'YEARLY' || 
                    subscription.subscriptionPlan.contains('YEARLY');
    
    return isYearly ? subscription.techpacksUsedThisYear : subscription.techpacksUsedThisMonth;
  }

  String _getBillingPeriodText(UserSubscription? subscription) {
    if (subscription == null) return 'month';
    
    // Check if it's a yearly subscription
    bool isYearly = subscription.billingPeriod == 'YEARLY' || 
                    subscription.subscriptionPlan.contains('YEARLY');
    
    return isYearly ? 'year' : 'month';
  }

  Widget _buildFeatureItem(String text) {
    return Padding(
      padding: EdgeInsets.only(bottom: 4),
      child: Row(
        children: [
          Icon(Icons.check_circle, color: Colors.green, size: 16),
          SizedBox(width: 8),
          Expanded(child: Text(text, style: ssTitleTextTextStyle124003)),
        ],
      ),
    );
  }

  // Collect all current tech pack details from form inputs
  Map<String, dynamic> _collectTechPackDetails() {
    return {
      'materials': {
        'mainFabric': mainFabricController.text,
        'secondaryMaterials': secondaryMaterialsController.text,
        'fabricProperties': fabricPropertiesController.text,
      },
      'colors': {
        'primaryColor': primaryColorController.text,
        'alternateColorways': alternateColorwaysController.text,
        'pantone': pantoneController.text,
      },
      'sizes': {
        'sizeRange': sizeRangeController.text,
        'measurementChart': measurementChartController.text,
        'measurementImage': measurementImagePath.value,
      },
      'technical': {
        'accessories': accessoriesController.text,
        'stitching': stitchingController.text,
        'decorativeStitching': decorativeStitchingController.text,
      },
      'labeling': {
        'logoPlacement': logoPlacementController.text,
        'labelsNeeded': labelsNeededController.text,
        'qrCode': qrCodeController.text,
      },
      'packaging': {
        'packagingType': packagingTypeController.text,
        'foldingInstructions': foldingInstructionsController.text,
        'inserts': insertsController.text,
      },
      'production': {
        'costPerPiece': costPerPieceController.text,
        'quantity': quantityController.text,
        'deliveryDate': deliveryDateController.text,
      },
    };
  }

  @override
  void onClose() {
    mainFabricController.dispose();
    secondaryMaterialsController.dispose();
    fabricPropertiesController.dispose();
    primaryColorController.dispose();
    alternateColorwaysController.dispose();
    pantoneController.dispose();
    sizeRangeController.dispose();
    measurementChartController.dispose();
    accessoriesController.dispose();
    stitchingController.dispose();
    decorativeStitchingController.dispose();
    logoPlacementController.dispose();
    labelsNeededController.dispose();
    qrCodeController.dispose();
    packagingTypeController.dispose();
    foldingInstructionsController.dispose();
    insertsController.dispose();
    costPerPieceController.dispose();
    quantityController.dispose();
    deliveryDateController.dispose();
    super.onClose();
  }
}
